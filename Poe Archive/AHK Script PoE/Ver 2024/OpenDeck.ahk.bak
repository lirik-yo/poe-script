#NoEnv  ; Recommended for performance and compatibility with future AutoHotkey releases.
#Warn  ; Enable warnings to assist with detecting common errors.
#SingleInstance Force
SendMode Input  ; Recommended for new scripts due to its superior speed and reliability.
SetWorkingDir %A_ScriptDir%  ; Ensures a consistent starting directory.

#Include message.ahk

AlreadyRunCommand := false
ItemsPoint := { LeftTop:{x:1288, y:607}, 	LeftBottom:{x:1296, y:825}, 	RightTop:{x:1878, y:619}, 	RightBottom:{x:1879, y:838}}
ItemsWidthCountCell = 12
ItemsHeightCountCell = 5

CountItemsPointProperty(){
	global ItemsPoint
	global ItemsWidthCountCell
	global ItemsHeightCountCell
	if (ItemsPoint.AvgLeftX <= 0){
		ItemsPoint.AvgLeftX := (ItemsPoint.LeftTop.x + ItemsPoint.LeftBottom.x) / 2
	}
	if (ItemsPoint.AvgRightX <= 0){
		ItemsPoint.AvgRightX := (ItemsPoint.RightTop.x + ItemsPoint.RightBottom.x) / 2
	}
	if (ItemsPoint.DX <= 0){
		ItemsPoint.DX := (ItemsPoint.AvgRightX - ItemsPoint.AvgLeftX) / (ItemsWidthCountCell - 1)
	}
	if (ItemsPoint.AvgTopY <= 0){
		ItemsPoint.AvgTopY := (ItemsPoint.LeftTop.y + ItemsPoint.RightTop.y) / 2
	}
	if (ItemsPoint.AvgBottomY <= 0){
		ItemsPoint.AvgBottomY := (ItemsPoint.LeftBottom.y + ItemsPoint.RightBottom.y) / 2
	}
	if (ItemsPoint.DY <= 0){
		ItemsPoint.DY := (ItemsPoint.AvgBottomY - ItemsPoint.AvgTopY) / (ItemsHeightCountCell - 1)
	}
}

GetPixelsByCoordinate(point){	
	global ItemsPoint
	CountItemsPointProperty()
	CellX := point.x * ItemsPoint.DX + ItemsPoint.AvgLeftX

	CellY := point.y * ItemsPoint.DY + ItemsPoint.AvgTopY
	return {x:CellX, y: CellY}
	
}

GetCoordinateByPixels(point){
	global ItemsPoint
	CountItemsPointProperty()
	CellX := Floor((point.x - (ItemsPoint.AvgLeftX - (ItemsPoint.DX / 2))) / ItemsPoint.DX)

	CellY := Floor((point.y - (ItemsPoint.AvgTopY - (ItemsPoint.DY / 2)))/ItemsPoint.DY)	
	return {x:CellX, y: CellY}	
}

AlreadyCheckedArray := 0

MoveNextCell(){
	global AlreadyCheckedArray
	global ItemsWidthCountCell
	global ItemsHeightCountCell
	if (AlreadyCheckedArray = 0){
		AlreadyCheckedArray := []
		Loop, %ItemsWidthCountCell% {
			XNum := A_Index
			Loop, %ItemsHeightCountCell% {
				AlreadyCheckedArray[XNum, A_Index] := false
			}
			
			; Loop, %ItemsHeightCountCell% {
				; AlreadyCheckedArray[%A_Index%].Push(false)
			; }
		}
		;Инициализация пустым массивом
	}
	FindX := -1
	FindY := -1
	Loop, %ItemsWidthCountCell% {
		XNum := A_Index
		Loop, %ItemsHeightCountCell% {
			if (not(AlreadyCheckedArray[XNum, A_Index])){
				FindX := XNum
				FindY := A_Index
				AlreadyCheckedArray[XNum, A_Index] := true
				break
			}
		}
		if (FindX >-1 )
		{
			break
		}
	}
	; AddMessage(FindX . ", " . FindY)
	if (FindX = -1){
		AlreadyCheckedArray := 0
		return false
	}else{
		return {x:FindX-1, y:FindY-1}
	}
}

GetCurrentItemAtCursor(){
	previousClipboard := clipboard
	clipboard := ""
	Send ^!c
	ClipWait, 0.12
	if ErrorLevel
	{
		return ""
	}
	result := clipboard
	clipboard := previousClipboard
	return result
}

CheckItemFullStackDivinationCard(){
	item := GetCurrentItemAtCursor()
	if (item = "")
		return false
	infoItem := GetInfoFromClipboard(item)
	
	if (infoItem.itemClass <> "Divination Cards")
		return false
	if (infoItem.count<infoItem.stackSize)
		return false
	return true
}
GetInfoFromClipboard(item){
	
	itemClass =
	
	; name =
	; rarity =
	; typeName =
	; last =
	count =
	stackSize =
	; caption =
	; note =
	; skip =
	; level =
	; quality =
	; corrupted =
	; negotiablePrice =
	; exactPrice =
	; sockets =
	
	Loop, parse, item, `n, `r
	{
		if (A_Index = 1)
		{
			checkText:= StrReplace(A_LoopField, " ")
			if (RegExMatch(checkText, "O)Item Class: (.*)", SubPart) > 0)
			{
				itemClass := SubPart.Value(1)
			}else{
				return false
			}
		}
		; if (A_Index = 2)
		; {
			; rarity := SubStr(A_LoopField, 9)
		; }
		; if (A_Index = 3)
		; {
			; name = %A_LoopField%
		; }
		; if (A_Index = 4)
		; {
			; typeName = %A_LoopField%
		; }
		if (A_Index = 5)
		{
			stack:= StrReplace(A_LoopField, " ")
			if (RegExMatch(stack, "O)Stack Size: ([\d\.]*)/([\d\.]*)", SubPart) > 0)
			{
				count := SubPart.Value(1)
				stackSize := SubPart.Value(2)
			}else{
				count:= 1
				stackSize:= 1
			}
		}
		
	}
		
	return {stackSize: stackSize, itemClass: itemClass, count: count} ;,    name: name,  typeName: typeName, price: SubStr(note, 7), caption: caption, text:text, rarity:rarity, level:level, quality:quality, corrupted:corrupted, skip:skip, negotiablePrice:negotiablePrice, exactPrice:exactPrice, note:note, sockets:sockets, tiers:tiers}
}

SendCardToTradeDivinationCard(){
	if (!WinActive("Path of Exile"))
		return
	
	while(true){
		NextPosition := MoveNextCell()
		if(NextPosition = false){
			AddMessage("Прошли всё, начинай сначала")		
			break
		}
		Pixels := GetPixelsByCoordinate(NextPosition)
		MouseMove,  Pixels.x, Pixels.y
		if (CheckItemFullStackDivinationCard()){			
			Send ^{Click}
			Sleep 250
			item := GetCurrentItemAtCursor()
			if (item <> ""){
				AddMessage("Не ушло в обмен")
				return false
			}
			Sleep 50
				; AddMessage("MouseClick")
			MouseClick, left, 621, 737
			Sleep 50
				; AddMessage("MouseMove")
			MouseMove,  625, 474
			Sleep 50
			Send ^{Click}
			Sleep 150
			item := GetCurrentItemAtCursor()
			if (item <> ""){
				AddMessage("Не ушло в инвентарь")
				return false
			}
			break
		}
	}  
	
}


CleanMessageAndSetTimeout(300)

`::
	if (not(AlreadyRunCommand)){
		AlreadyRunCommand := true
		SendCardToTradeDivinationCard()
		AlreadyRunCommand := false
	}
return